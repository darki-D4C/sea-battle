package org.krista.seabattle.services;

import org.krista.seabattle.models.BattleShip;
import org.krista.seabattle.models.Coordinate;
import org.krista.seabattle.models.GameField;
import org.krista.seabattle.utility.GameStatus;
import org.krista.seabattle.utility.BasicAI;

import javax.enterprise.context.SessionScoped;
import java.io.Serializable;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Class to represent Game logic, a CDI Bean.
 */
@SessionScoped
public class GameService implements Serializable {

    private final GameField playerField = new GameField();
    private final GameField serverField = new GameField();
    private ArrayList<Coordinate> alreadyAttackedByServer = new ArrayList<>();
    private GameStatus status = GameStatus.NOT_STARTED;
    private Random rand;
    private static final long serialVersionUID = 2391050890685433701L;


    /**
     * Place server ships, that were generated by an AI.
     */
    public GameService() {
        try {
            rand = SecureRandom.getInstanceStrong();
        } catch (NoSuchAlgorithmException e) {
            rand = new Random();
        }
        generateRandomShipsAndPlaceThem();
    }

    public void generateRandomShipsAndPlaceThem() {
        BasicAI ai = new BasicAI();
        for (BattleShip ship : ai.getShips()) {
            serverField.updateField(ship);
        }
    }

    /**
     * Method to place ships and update player field.
     *
     * @param ships to be placed
     */
    public void placePlayerShips(List<BattleShip> ships) {
        for (BattleShip ship : ships) {
            playerField.updateField(ship);
        }
        this.status = GameStatus.ONGOING;
    }

    /**
     * Method to validate player sent ships.
     *
     * @param ships to validate
     * @return valid or invalid
     */
    public boolean checkPlayerShips(List<BattleShip> ships) {
        if (ships == null) return false;
        int[][] checkField = playerField.getField();
        for (BattleShip ship : ships) {
            if (!checkShip(ship, checkField)) return false;
            for (Coordinate coord : ship.getRemainingShipParts()) {
                if ((checkField[coord.getX()][coord.getY()] != 1)) {
                    checkField[coord.getX()][coord.getY()] = 1;
                } else return false;
            }
        }
        return true;
    }

    /**
     * Validate specific ship.
     *
     * @param ship       to validate
     * @param checkField mock field to check ship on
     * @return valid or not
     */
    public boolean checkShip(BattleShip ship, int[][] checkField) {
        int[][] field = playerField.getField();
        List<Coordinate> coords = ship.getRemainingShipParts();

        for (Coordinate coord : coords) {
            if ((field[coord.getX()][coord.getY()] == 1) || playerField.checkValidity(coord)) {
                return false;
            }
        }

        int x = coords.get(0).getX();
        int y = coords.get(0).getY();
        for (int i = 1; i < ship.getNumberOfDecks(); i++) {
            if (!(coords.get(i).getX() == x || coords.get(i).getY() == y) || (coords.get(i).getX() == x && coords.get(i).getY() == y)) {
                // Если либо x либо y , не совпадают с
                // соответсвующими x y первой палубы,
                //то палуба не находится на одной линии с первой
                return false;
            }
        }
        for (Coordinate coord : ship.getShipParts()) {
            if ((coord.getX() + 1 < 10 && checkField[coord.getX() + 1][coord.getY()] == 1 && !ship.hasPart(new Coordinate(coord.getX() + 1, coord.getY()))) ||
                    (coord.getX() - 1 > 0 && checkField[coord.getX() - 1][coord.getY()] == 1 && !ship.hasPart(new Coordinate(coord.getX() - 1, coord.getY())) ||
                            (coord.getY() + 1 < 10 && checkField[coord.getX()][coord.getY() + 1] == 1 && !ship.hasPart(new Coordinate(coord.getX(), coord.getY() + 1)))) ||
                    (coord.getY() -1 > 0 && checkField[coord.getX()][coord.getY() - 1] == 1 && !ship.hasPart(new Coordinate(coord.getX(), coord.getY() - 1)))) {
                return false;
            }
        }
        return true;
    }

    public GameField getPlayerField() {
        return playerField;
    }

    public GameField getServerField() {
        return serverField;
    }

    /**
     * Method to check server coord if it is empty  or not.
     *
     * @param coord to check
     * @return empty or not empty ( boolean)
     */
    public boolean checkServerCoord(Coordinate coord) {
        return serverField.getField()[coord.getX()][coord.getY()] == 1;
    }

    /**
     * Method to chain attack player field.
     *
     * @return status of attack( can be complete miss, or list of destroyed ships / coords)
     */
    public List<List<Coordinate>> attackPlayerField() {
        List<List<Coordinate>> attackList = new ArrayList<>();

        List<Coordinate> serverAttack = new ArrayList<>(attackPlayerTile());
        while (!serverAttack.isEmpty()) {
            attackList.add(serverAttack);
            serverAttack = new ArrayList<>(attackPlayerTile());
        }

        return attackList;

    }

    public List<Coordinate> attackPlayerTile() {
        Coordinate coordToAttack;
        List<Coordinate> destroyedParts = new ArrayList<>();
        coordToAttack = generateCoord();
        if (getPlayerField().getField()[coordToAttack.getX()][coordToAttack.getY()] == 1) {
            getPlayerField().attackCoord(coordToAttack);
            BattleShip foundShip = getPlayerField().findShipByCord(coordToAttack);
            if (foundShip.getNumberOfDecks() == 0) {
                destroyedParts.addAll(foundShip.getShipParts());
                getPlayerField().clearShip(foundShip);
                return destroyedParts;
            }
            destroyedParts.add(coordToAttack);
        }
        return destroyedParts;
    }

    /**
     * Method to generate coord that was not yet attacked.
     *
     * @return coord that was not yet attacked
     */
    public Coordinate generateCoord() {

        int randomX = this.rand.nextInt(9);
        int randomY = this.rand.nextInt(9);
        Coordinate pickedCord = new Coordinate(randomX, randomY);
        while ((getAttackedCoordsByServer().contains(pickedCord))) {
            randomX = this.rand.nextInt(9);
            randomY = this.rand.nextInt(9);
            pickedCord = new Coordinate(randomX, randomY);
        }
        return pickedCord;
    }

    public List<Coordinate> getAttackedCoordsByServer() {
        return alreadyAttackedByServer;
    }

    /**
     * Method to check if certain side has any ships left.
     *
     * @param side side to check
     * @return game over or not( true / false)
     */
    public boolean checkGameOver(String side) {
        if (side.equals("player")) {
            for (BattleShip ship : getPlayerField().getShips()) {
                if (ship.getNumberOfDecks() != 0) {
                    return false;
                }
            }
            setStatus(GameStatus.FINISHED_S);
        }
        if (side.equals("server")) {
            for (BattleShip ship : getServerField().getShips()) {
                if (ship.getNumberOfDecks() != 0) {

                    return false;
                }
            }
            setStatus(GameStatus.FINISHED_P);
        }
        return true;
    }

    public GameStatus getStatus() {
        return this.status;
    }

    public void setStatus(GameStatus status) {
        this.status = status;
    }


    public void clearFields() {
        playerField.clearSelf();
        serverField.clearSelf();
        this.alreadyAttackedByServer = new ArrayList<>();
    }


}
