package org.krista.seabattle;

import javax.enterprise.context.SessionScoped;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.json.*;

/**
 * Class to represent Game logic, a CDI Bean
 */
@SessionScoped
public class GameService implements Serializable {

    private GameField playerField = new GameField();
    private GameField serverField = new GameField();
    private ArrayList<Coordinate> alreadyAttackedByServer = new ArrayList<>();


    /**
     * Place server ships, that were generated by an AI
     */
    public GameService() {
        BasicAI ai = new BasicAI();
        for (BattleShip ship : ai.getShips()) {
            serverField.updateField(ship);
        }

    }

    /**
     * Method to place ships and update player field
     *
     * @param ships , to be placed
     */
    public void placePlayerShips(List<BattleShip> ships) {
        for (BattleShip ship : ships) {
            playerField.updateField(ship);
        }
    }

    /**
     * Method to validate player sent ships
     *
     * @param ships, to validate
     * @return valid or invalid
     */
    public boolean checkPlayerShips(List<BattleShip> ships) {
        // if(ships == null) return false;
        int[][] checkField = playerField.getField();
        for (BattleShip ship : ships) {
            if (!checkShip(ship)) return false;
            for (Coordinate coord : ship.getRemainingShipParts()) {
                if (!(checkField[coord.getX()][coord.getY()] == 1)) {
                    checkField[coord.getX()][coord.getY()] = 1;
                } else return false;
            }
        }
        return true;
    }

    /**
     * Validate specific ship
     *
     * @param ship, to validate
     * @return valid or not
     */
    private boolean checkShip(BattleShip ship) {
        int[][] field = playerField.getField();
        List<Coordinate> coords = ship.getRemainingShipParts();

        for (Coordinate coord : coords) {
            if (field[coord.getX()][coord.getY()] == 1) {
                return false;
            }
        }


        int x = (int) coords.get(0).getX();
        int y = (int) coords.get(0).getY();
        for (int i = 1; i < ship.getNumberOfDecks() - 1; i++) {
            if (!(coords.get(i).getX() == x || coords.get(i).getY() == y) || (coords.get(i).getX() == x && coords.get(i).getY() == y)) {
                // Если либо x либо y , не совпадают с
                // соответсвующими x y первой палубы,
                //то палуба не находится на одной линии с первой
                return false;
            }
        }
        return true;
    }

    public GameField getPlayerField() {
        return playerField;
    }

    public GameField getServerField() {
        return serverField;
    }

    /**
     * Method to check server coord if it is empty  or not
     *
     * @param coord, to check
     * @return empty or not empty ( boolean)
     */
    public boolean checkServerCoord(Coordinate coord) {

        return serverField.getField()[coord.getX()][coord.getY()] == 1;

    }

    /**
     * Method to chain attack player field
     *
     * @return status of attack( can be complete miss, or list of destroyed ships / coords)
     */
    public JsonArray attackPlayerField() {
        boolean serverTurn = true;
        JsonArrayBuilder serverTurnActions = Json.createArrayBuilder();
        serverTurnActions.add(Json.createObjectBuilder().add("side", "server").build());
        Coordinate coordToAttack;
        while (serverTurn) {
            coordToAttack = generateCoord();
            if (getPlayerField().getField()[coordToAttack.getX()][coordToAttack.getY()] == 1) {
                getPlayerField().attackCoord(coordToAttack);
                BattleShip foundShip = getPlayerField().findShipByCord(coordToAttack);
                if (foundShip.getNumberOfDecks() == 0) {
                    serverTurnActions = JsonCreator.addInfoAboutDestroyedShip(serverTurnActions, foundShip);
                    continue;
                }
                serverTurnActions = JsonCreator.addInfoAboutDestroyedCord(serverTurnActions, coordToAttack);
            } else {
                serverTurn = false;
            }
        }

        JsonArray arr = serverTurnActions.build();
        if (arr.size() - 1 == 0) {
            return JsonCreator.returnInfoAboutCompleteMiss();
        }

        return arr;
    }

    /**
     * Method to generate coord that was not yet attacked
     *
     * @return coord, that was not yet attacked
     */
    public Coordinate generateCoord() {
        int randomX = (int) (Math.random() * 10);
        int randomY = (int) (Math.random() * 10);
        Coordinate pickedCord = new Coordinate(randomX, randomY);
        while ((getAttackedCoordsByServer().contains(pickedCord))) {
            randomX = (int) (Math.random() * 10);
            randomY = (int) (Math.random() * 10);
            pickedCord = new Coordinate(randomX, randomY);
        }
        return pickedCord;
    }

    public List<Coordinate> getAttackedCoordsByServer() {
        return alreadyAttackedByServer;
    }

    /**
     * Method to check if certain side has any ships left
     *
     * @param side, side to check
     * @return game over or not( true / false)
     */
    public boolean checkGameOver(String side) {
        if (side.equals("player")) {
            for (BattleShip ship : getPlayerField().getShips()) {
                if (ship.getNumberOfDecks() != 0) {
                    return false;
                }
            }
        }
        if (side.equals("server")) {
            for (BattleShip ship : getServerField().getShips()) {
                if (ship.getNumberOfDecks() != 0) {
                    return false;
                }
            }
        }
        return true;
    }
}
